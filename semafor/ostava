
// void init_TIM1() {
//   /// wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
//   ///  setup PWM on TIM4 CH1, CH2, CH3 & CH4 -> PD12, PD13, PD14 & PD15
//   ///----------------------------------------------------------------
//   RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; //
//   GPIOA->MODER |= 0x00020000;          //
//   GPIOA->OTYPER |= 0x00000000;         //
//   GPIOA->AFR[1] |= 0x00000001;         //
//
//   RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;
//   GPIOE->MODER |= 0x00080000;
//   GPIOE->OTYPER |= 0x00000000;
//   GPIOE->AFR[1] |= 0x00000010;
//
//   RCC->APB2ENR |= RCC_APB2ENR_TIM1EN; // enable TIM1 on APB2
//   TIM1->PSC = 0x0002 - 0x0001;        // 2 - 1
//   TIM1->ARR = 0x0069 - 0x0001;        // period of the PWM 1.25us
//   // 105
//   TIM1->CCR1 = 0x0000; // duty cycle for the PWM set to 0%
//   TIM4->CCR2 = 0x0000;
//   // TIM4->CCR3 = 0x0000;
//   // TIM4->CCR4 = 0x0000;
//
//   TIM1->CCMR1 |= (TIM_CCMR1_OC1PE) | (TIM_CCMR1_OC1M_2) | (TIM_CCMR1_OC1M_1);
//   // TIM1->CCMR1 |= (TIM_CCMR1_OC2PE) | (TIM_CCMR1_OC2M_2) |
//   (TIM_CCMR1_OC2M_1);
//   // TIM1->CCMR2 |= (TIM_CCMR2_OC3PE) | (TIM_CCMR2_OC3M_2) |
//   (TIM_CCMR2_OC3M_1);
//   // TIM1->CCMR2 |= (TIM_CCMR2_OC4PE) | (TIM_CCMR2_OC4M_2) |
//   (TIM_CCMR2_OC4M_1);
//   // set PWM 1 mod, enable OC1PE preload mode
//
//   // set active mode high for pulse polarity
//   // TIM1->CCER &=
//   //     ~((TIM_CCER_CC1P) | (TIM_CCER_CC2P) | (TIM_CCER_CC3P) |
//   //     (TIM_CCER_CC4P));
//
//   TIM1->CCER &= ~(TIM_CCER_CC1P);
//   TIM1->CR1 |= (TIM_CR1_ARPE) | (TIM_CR1_URS);
//
//   TIM1->CR2 |= TIM_CR2_CCDS;
//
//   // update event, reload all config
//   TIM1->EGR |= TIM_EGR_UG;
//   // activate ca(uint32_t) pture compare mode
//   // TIM1->CCER |=
//   //     (TIM_CCER_CC1E) | (TIM_CCER_CC2E) | (TIM_CCER_CC3E) |
//   (TIM_CCER_CC4E);
//
//   TIM1->CCER |= (TIM_CCER_CC1E);
//
//   TIM1->DIER |= TIM_DIER_UDE;
//   TIM1->DIER |= TIM_DIER_CC1DE | TIM_DIER_TDE;
//   TIM1->EGR |= TIM_EGR_CC3G;
//   TIM1->EGR |= TIM_EGR_TG;
//   // start counter
//   // TIM1->CR1 |= TIM_CR1_CEN;
// }
//
//
//
// void init_DMA2() {
//   // Channel 6 Stream 1 -> TIM1->CH1
//   RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
//
//   DMA2_Stream1->CR &= ~DMA_SxCR_EN;
//   while (DMA2_Stream1->CR & DMA_SxCR_EN)
//     ;
//
//   DMA2_Stream1->CR &= 0xF0100000; // keep reserved bits
//
//   // DMA2->LISR ^= DMA2->LISR;
//   // DMA2->HISR ^= DMA2->HISR;
//
//   DMA2_Stream1->PAR = (uint32_t) & (TIM1->CCR1);
//   // DMA1_Stream1->PAR = (uint32_t) & (TIM1->DMAR);
//   DMA2_Stream1->M0AR = (uint32_t)colorBuff;
//
//   DMA2_Stream1->NDTR = buffSize * MAX_LED + 50;
//   // TIM4->DCR |= 0x010F;
//   // DMA2_Stream1->NDTR = buffSize * MAX_LED;
//
//   DMA2_Stream1->CR |= 0x0C000000;    // Channel 6
//   DMA2_Stream1->CR |= DMA_SxCR_PL_1; // priority high
//
//   DMA2_Stream1->CR |= DMA_SxCR_DIR_0;
//   DMA2_Stream1->CR |= DMA_SxCR_MINC;
//   DMA2_Stream1->CR |= DMA_SxCR_TCIE;
//
//   DMA2_Stream1->CR |= DMA_SxCR_MSIZE_0;
//   DMA2_Stream1->CR |= DMA_SxCR_PSIZE_0;
//
//   // DMA2_Stream1->CR |= DMA_SxCR_EN;
//   NVIC_SetPriority(DMA2_Stream1_IRQn, 0); // mozda?
//   NVIC_EnableIRQ(DMA2_Stream1_IRQn);      // mozda?
// }

// void DMA2_Stream1_IRQHandler(void) {
//   printUSART2("GPIOA->ODR -> [%x]\n", GPIOA->ODR);
//   printUSART2("isr\n");
//   DMA2->LIFCR |= DMA_LIFCR_CTCIF1;
//   TIM1->CR1 &= ~TIM_CR1_CEN;
//   DMA2_Stream1->CR &= ~DMA_SxCR_EN;
//   datasentflag = 1;
// }

// void send(int green, int red, int blue) {
//   uint32_t data = (blue << 16) | (red << 8) | green;
//   int i;
//   for (i = 23; i >= 0; --i) {
//     if (data & (1 << i))
//       colorBuff[i] = pwm[1];
//     else
//       colorBuff[i] = pwm[0];
//   }
//   // TIM4->CR1 |= TIM_CR1_CEN;
//   // DMA1_Stream7->CR |= DMA_SxCR_EN;
// }
